// c version 1 36ms
double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {
    int all[nums1Size + nums2Size];
    if(nums1 == NULL){
        return nums2Size % 2 ? nums2[nums2Size / 2] : (nums2[nums2Size / 2] + nums2[nums2Size / 2 - 1]) / 2.0;
    }
    if(nums2 == NULL){
        return nums1Size % 2 ? nums1[nums1Size / 2] : (nums1[nums1Size / 2] + nums1[nums1Size / 2 - 1]) / 2.0;
    }
    for(int i = 0, index1 = 0, index2 = 0; index1 < nums1Size || index2 < nums2Size; ++i){
        if(index1 == nums1Size){
            all[index1 + index2] = nums2[index2];
            index2++;
        }
        else if(index2 == nums2Size){
            all[index1 + index2] = nums1[index1];
            index1++;
        }
        else if(nums1[index1] < nums2[index2]){
            all[index1 + index2] = nums1[index1];
            index1++;
        }
        else{
            all[index1 + index2] = nums2[index2];
            index2++;
        }
    }
    return (nums1Size + nums2Size) % 2 ? all[(nums1Size + nums2Size) / 2] : (all[(nums1Size + nums2Size) / 2] + all[(nums1Size + nums2Size) / 2 - 1]) / 2.0;
}
// c version 2 24ms

double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {
    int totalSize = nums1Size + nums2Size;
    if(totalSize % 2 == 0) {
        int m = findTargetNumber(nums1, nums2, totalSize/2, nums1Size, nums2Size);
        int n = findTargetNumber(nums1, nums2, totalSize/2+1, nums1Size, nums2Size);
        return ( m+n )/2.0;
        
    } else {
        return 1.0 * findTargetNumber(nums1, nums2, (totalSize+1)/2, nums1Size, nums2Size);
    }
}
int findTargetNumber(int* nums1, int *nums2, int target, int nums1Size,int nums2Size) {
    if(nums1Size == 0)
        return nums2[target-1];
    if(nums2Size == 0)
        return nums1[target-1]; 
    if(target == 1) {
        return *nums1>*nums2?*nums2:*nums1;
    }
    if(*nums1 < *nums2) {
        if(!*(nums1+1)) 
        return findTargetNumber(nums1, nums2, target-1, 0,nums2Size);
        return findTargetNumber(nums1+1, nums2, target-1, nums1Size-1, nums2Size);
    } else {    
        if(!*(nums2+1)) 
        return findTargetNumber(nums1, nums2, target-1, nums1Size,0);
        return findTargetNumber(nums1, nums2+1, target-1, nums1Size, nums2Size-1);
    }
}

//c version 3 24ms

double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {
    int all[(nums1Size + nums2Size) / 2 + 1];
    if(nums1 == NULL){
        return nums2Size % 2 ? nums2[nums2Size / 2] : (nums2[nums2Size / 2] + nums2[nums2Size / 2 - 1]) / 2.0;
    }
    if(nums2 == NULL){
        return nums1Size % 2 ? nums1[nums1Size / 2] : (nums1[nums1Size / 2] + nums1[nums1Size / 2 - 1]) / 2.0;
    }
    for(int i = 0, index1 = 0, index2 = 0; i < (nums1Size + nums2Size) / 2 + 1; ++i){
        if(index1 == nums1Size){
            all[index1 + index2] = nums2[index2];
            index2++;
        }
        else if(index2 == nums2Size){
            all[index1 + index2] = nums1[index1];
            index1++;
        }
        else if(nums1[index1] < nums2[index2]){
            all[index1 + index2] = nums1[index1];
            index1++;
        }
        else{
            all[index1 + index2] = nums2[index2];
            index2++;
        }
    }
    return (nums1Size + nums2Size) % 2 ? all[(nums1Size + nums2Size) / 2] : (all[(nums1Size + nums2Size) / 2] + all[(nums1Size + nums2Size) / 2 - 1]) / 2.0;
}

// c++ version 1 32ms
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int nums1Size = nums1.size();
        int nums2Size = nums2.size();
        int all[(nums1Size + nums2Size) / 2 + 1];
        if(nums1Size == 0)
            return nums2Size % 2 ? nums2[nums2Size / 2] : (nums2[nums2Size / 2] + nums2[nums2Size / 2 - 1]) / 2.0;       
        if(nums2Size == 0)
            return nums1Size % 2 ? nums1[nums1Size / 2] : (nums1[nums1Size / 2] + nums1[nums1Size / 2 - 1]) / 2.0;
    
        for(int i = 0, index1 = 0, index2 = 0; i < (nums1Size + nums2Size) / 2 + 1; ++i){
            if(index1 == nums1Size)
                all[index1 + index2] = nums2[index2++];        
            else if(index2 == nums2Size)
                all[index1 + index2] = nums1[index1++];
            else if(nums1[index1] < nums2[index2])
                all[index1 + index2] = nums1[index1++];
            else
                all[index1 + index2] = nums2[index2++];
        }
    return (nums1Size + nums2Size) % 2 ? all[(nums1Size + nums2Size) / 2] : (all[(nums1Size + nums2Size) / 2] + all[(nums1Size + nums2Size) / 2 - 1]) / 2.0;
    }
};


// c++ version 2 16ms
static const auto speedup = [](){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    return nullptr;
}();


class Solution {
public:
   double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    int N1 = nums1.size();
    int N2 = nums2.size();
    if (N1 < N2) return findMedianSortedArrays(nums2, nums1);	// Make sure A2 is the shorter one.
    
    int lo = 0, hi = N2 * 2;
    while (lo <= hi) {
        int mid2 = (lo + hi) / 2;   // Try Cut 2 
        int mid1 = N1 + N2 - mid2;  // Calculate Cut 1 accordingly
        
        double L1 = (mid1 == 0) ? INT_MIN : nums1[(mid1-1)/2];	// Get L1, R1, L2, R2 respectively
        double L2 = (mid2 == 0) ? INT_MIN : nums2[(mid2-1)/2];
        double R1 = (mid1 == N1 * 2) ? INT_MAX : nums1[(mid1)/2];
        double R2 = (mid2 == N2 * 2) ? INT_MAX : nums2[(mid2)/2];
        
        if (L1 > R2) lo = mid2 + 1;		// A1's lower half is too big; need to move C1 left (C2 right)
        else if (L2 > R1) hi = mid2 - 1;	// A2's lower half too big; need to move C2 left.
        else return (max(L1,L2) + min(R1, R2)) / 2;	// Otherwise, that's the right cut.
    }
    return -1;
} 
};
